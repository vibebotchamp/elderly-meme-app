<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>é•·è¼©åœ–ç¥å™¨ (å¤©æ°£æ—¥æœŸç‰ˆ)</title>
<style>
  /* --- CSS æ¨£å¼ --- */
  :root {
    --bg-color: #FFF9E1;
    --primary-color: #d32f2f;
  }

  body {
    font-family: 'Microsoft JhengHei', sans-serif;
    background-color: var(--bg-color);
    margin: 0;
    padding: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    box-sizing: border-box;
  }

  h1 {
    color: var(--primary-color);
    margin: 10px 0 20px 0;
    text-align: center;
    font-size: 1.6rem;
    line-height: 1.4;
  }

  .app-container {
    width: 100%;
    max-width: 450px;
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  /* ç•«å¸ƒå®¹å™¨ */
  .canvas-wrapper {
    width: 100%;
    aspect-ratio: 1 / 1;
    border: 8px solid white;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    background: #ccc;
    position: relative;
    border-radius: 4px;
    overflow: hidden;
  }

  canvas {
    width: 100%;
    height: 100%;
    display: block;
  }

  #status-msg {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 1.5rem;
    color: #666;
    font-weight: bold;
    pointer-events: none;
    display: none;
    background: rgba(255,255,255,0.8);
    padding: 10px 20px;
    border-radius: 10px;
    white-space: nowrap;
  }

  .controls {
    display: flex;
    flex-direction: column;
    gap: 15px;
  }

  select {
    width: 100%;
    font-size: 1.4rem;
    padding: 12px;
    border: 2px solid var(--primary-color);
    border-radius: 10px;
    background: white;
    color: #333;
    font-weight: bold;
  }

  button {
    width: 100%;
    padding: 15px;
    font-size: 1.4rem;
    font-weight: bold;
    color: white;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    box-shadow: 0 4px 0 rgba(0,0,0,0.2);
  }
  button:active {
    transform: translateY(2px);
    box-shadow: 0 2px 0 rgba(0,0,0,0.2);
  }

  #refresh-btn { background-color: #ff9800; }
  #download-btn { background-color: #2e7d32; }

  /* iOS å„²å­˜åœ–ç‰‡å½ˆçª— */
  #save-modal {
    display: none;
    position: fixed;
    z-index: 999;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.95);
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  #save-modal img {
    width: 90%;
    max-width: 400px;
    border: 5px solid white;
    margin-bottom: 20px;
  }

  #save-modal p {
    color: yellow;
    font-size: 1.5rem;
    font-weight: bold;
    margin-bottom: 20px;
    text-align: center;
    line-height: 1.5;
  }

  #close-modal-btn {
    background-color: #d32f2f;
    width: auto;
    padding: 10px 40px;
    border: 2px solid white;
  }

</style>
</head>
<body>

<div class="app-container">
  <h1>âœ¨ æ™ºæ…§é•·è¼©åœ– âœ¨<br><span style="font-size:1rem; color:#666;">å³æ™‚å¤©æ°£ x æ¯æ—¥å•å€™</span></h1>

  <div class="canvas-wrapper">
    <div id="status-msg">å¤©æ°£å®šä½ä¸­...</div>
    <canvas id="memeCanvas" width="600" height="600"></canvas>
  </div>

  <div class="controls">
    <select id="category-select"></select>
    <button id="refresh-btn">ğŸ”„ æ›ä¸€å¼µåœ–</button>
    <button id="download-btn">â¬‡ï¸ ä¸‹è¼‰/å„²å­˜åœ–ç‰‡</button>
  </div>
</div>

<div id="save-modal">
  <p>ğŸ‘‡ è«‹é•·æŒ‰ä¸‹æ–¹åœ–ç‰‡ ğŸ‘‡<br>é¸æ“‡ã€ŒåŠ å…¥ç…§ç‰‡ã€</p>
  <img id="modal-img" src="" alt="ç”Ÿæˆçš„é•·è¼©åœ–">
  <button id="close-modal-btn">âŒ é—œé–‰è¦–çª—</button>
</div>

<script>
  // --- 1. è³‡æ–™åº«è¨­å®š ---
  const memeData = {
    "æ—©å®‰": { keyword: "morning,sunlight,nature", phrases: ["æ—©å®‰ï¼ç¾å¥½çš„ä¸€å¤©", "å¹³å®‰å–œæ¨‚", "ç¥æ‚¨é †å¿ƒå¦‚æ„", "æ—©å®‰ï¼Œè¨˜å¾—åƒæ—©é¤", "å¥åº·æ˜¯ç¦", "æ–°çš„ä¸€å¤©ï¼Œæ´»åŠ›æ»¿æ»¿"] },
    "æ™šå®‰": { keyword: "night,stars,moon", phrases: ["æ™šå®‰ï¼Œå¥½å¤¢é€£é€£", "è¾›è‹¦äº†ï¼Œæ—©é»ä¼‘æ¯", "ç¥ä½ æœ‰å€‹å¯§éœçš„å¤œæ™š", "ç¡å€‹å¥½è¦ºï¼Œæ˜å¤©æ›´å¥½", "æ˜Ÿå…‰ä¼´æ‚¨å…¥çœ "] },
    "ç”Ÿæ—¥å¿«æ¨‚": { keyword: "cake,party,balloons", phrases: ["ç¥ä½ ç”Ÿæ—¥å¿«æ¨‚ï¼", "ç”Ÿæ—¥å¤§å‰ï¼Œç¦å¦‚æ±æµ·", "å¤©å¤©é–‹å¿ƒï¼Œç”Ÿæ—¥æ„‰å¿«", "é¡˜æ‚¨é’æ˜¥æ°¸é§", "å£½æ¯”å—å±±"] },
    "é€±æœ«æ„‰å¿«": { keyword: "relax,coffee,park", phrases: ["é€±æœ«æ„‰å¿«ï¼Œæ”¾é¬†å¿ƒæƒ…", "äº«å—ç¾å¥½å‡æœŸ", "å‡æ—¥å¿«æ¨‚ï¼Œå‡ºé–€èµ°èµ°", "ä¼‘æ¯æ˜¯ç‚ºäº†èµ°æ›´é•·çš„è·¯"] },
    "å¤©æ°£è®Šå†·": { keyword: "winter,cold,tea", phrases: ["å¤©å†·äº†ï¼Œè¨˜å¾—å¤šç©¿ä»¶è¡£æœ", "æ³¨æ„ä¿æš–ï¼Œèº«é«”å¥åº·", "å¯’æµä¾†è¥²ï¼Œä¿é‡èº«é«”", "å–æ¯ç†±èŒ¶ï¼Œæš–æš–èº«å­"] },
    "æ­£èƒ½é‡": { keyword: "motivation,success,road", phrases: ["å …æŒåˆ°åº•ï¼Œå°±æ˜¯å‹åˆ©", "çŸ¥è¶³å¸¸æ¨‚", "å¿ƒå­˜å–„å¿µï¼Œå¿…æœ‰å¾Œç¦", "æ´»åœ¨ç•¶ä¸‹ï¼Œå¿«æ¨‚æ¯ä¸€å¤©"] },
    "æ–°å¹´å¿«æ¨‚": { keyword: "red,lantern,new year", phrases: ["æ–°å¹´å¿«æ¨‚ï¼Œæ­¥æ­¥é«˜å‡", "è¬äº‹å¦‚æ„ï¼Œå¤§å‰å¤§åˆ©", "æ­å–œç™¼è²¡ï¼Œç´…åŒ…æ‹¿ä¾†", "é´»é‹ç•¶é ­"] },
    "é™¤å¤•": { keyword: "dinner,family", phrases: ["é™¤å¤•åœ˜åœ“ï¼Œå…¨å®¶å¹³å®‰", "è¾­èˆŠè¿æ–°ï¼Œå¥½é‹å¹´å¹´", "å¹´å¤œé£¯é¦™ï¼Œå¹¸ç¦æ»¿å ‚"] },
    "åˆä¸€": { keyword: "temple,gold", phrases: ["å¤§å¹´åˆä¸€èµ°æ˜¥æ‹œå¹´", "æ­å–œç™¼è²¡ç¬‘å“ˆå“ˆ", "é–‹æ˜¥å¤§å‰å¥½å…†é ­", "åˆä¸€ç´…åŒ…è³ºå¤§éŒ¢"] },
  };

  // --- 2. è®Šæ•¸èˆ‡ DOM ---
  const canvas = document.getElementById('memeCanvas');
  const ctx = canvas.getContext('2d');
  const statusMsg = document.getElementById('status-msg');
  const categorySelect = document.getElementById('category-select');
  const saveModal = document.getElementById('save-modal');
  const modalImg = document.getElementById('modal-img');
  
  let currentCategory = "æ—©å®‰";
  let currentText = "";
  // é è¨­å¤©æ°£è³‡è¨Š (è‹¥æŠ“ä¸åˆ°å®šä½æ™‚ä½¿ç”¨)
  let weatherInfo = {
    temp: "--",
    code: -1,
    city: "å®šä½ä¸­"
  };

  // --- 3. åˆå§‹åŒ– ---
  function init() {
    // å¡«å……é¸å–®
    Object.keys(memeData).forEach(key => {
      let opt = document.createElement('option');
      opt.value = key;
      opt.textContent = key;
      categorySelect.appendChild(opt);
    });

    // ç¶å®šäº‹ä»¶
    categorySelect.addEventListener('change', (e) => {
      currentCategory = e.target.value;
      generateContent();
    });
    document.getElementById('refresh-btn').addEventListener('click', generateContent);
    document.getElementById('download-btn').addEventListener('click', openSaveModal);
    document.getElementById('close-modal-btn').addEventListener('click', () => saveModal.style.display = 'none');

    // å•Ÿå‹•å¤©æ°£ç²å–
    getWeatherData();
  }

  // --- 4. æ°£è±¡é‚è¼¯ (Open-Meteo API) ---
  function getWeatherData() {
    statusMsg.style.display = 'block';
    
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          const lat = position.coords.latitude;
          const lon = position.coords.longitude;
          fetchWeather(lat, lon, "ç•¶åœ°");
        },
        (error) => {
          console.warn("æ‹’çµ•å®šä½æˆ–å¤±æ•—ï¼Œä½¿ç”¨å°åŒ—é è¨­å€¼");
          fetchWeather(25.03, 121.56, "å°åŒ—"); // é è¨­å°åŒ—
        }
      );
    } else {
      fetchWeather(25.03, 121.56, "å°åŒ—");
    }
  }

  function fetchWeather(lat, lon, cityName) {
    const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true`;
    
    fetch(url)
      .then(response => response.json())
      .then(data => {
        weatherInfo = {
          temp: Math.round(data.current_weather.temperature),
          code: data.current_weather.weathercode,
          city: cityName
        };
        // å¤©æ°£æŠ“å®Œå¾Œï¼Œç”¢ç”Ÿç¬¬ä¸€å¼µåœ–
        generateContent();
      })
      .catch(err => {
        console.error("å¤©æ°£ API å¤±æ•—", err);
        weatherInfo.city = "å°ç£"; // å¤±æ•—å¾Œçš„å‚™æ¡ˆ
        generateContent();
      });
  }

  // å¤©æ°£ä»£ç¢¼è½‰ emoji
  function getWeatherIcon(code) {
    if (code === -1) return "âœ¨";
    if (code <= 1) return "â˜€ï¸"; // æ™´å¤©
    if (code <= 3) return "â›…"; // å¤šé›²
    if (code <= 48) return "ğŸŒ«ï¸"; // éœ§
    if (code <= 67) return "ğŸŒ§ï¸"; // é›¨
    if (code <= 82) return "â›ˆï¸"; // å¼·é›¨
    if (code <= 99) return "ğŸŒ©ï¸"; // é›·é›¨
    return "ğŸŒ¥ï¸";
  }

  // --- 5. æ ¸å¿ƒç”Ÿæˆé‚è¼¯ ---
  function generateContent() {
    statusMsg.style.display = 'block';
    statusMsg.textContent = "åœ–ç‰‡ç”Ÿæˆä¸­...";
    
    const data = memeData[currentCategory];
    currentText = data.phrases[Math.floor(Math.random() * data.phrases.length)];
    
    const img = new Image();
    img.crossOrigin = "Anonymous"; 
    
    // 3ç§’è¶…æ™‚æ©Ÿåˆ¶
    const timeoutId = setTimeout(() => {
        console.log("åœ–ç‰‡é€¾æ™‚");
        drawCanvas(null);
    }, 3000);

    img.onload = function() {
      clearTimeout(timeoutId);
      drawCanvas(img);
    };

    img.onerror = function() {
      clearTimeout(timeoutId);
      drawCanvas(null);
    };

    // ä½¿ç”¨ Picsum æŠ“åœ–
    const randomSeed = Math.floor(Math.random() * 9999);
    img.src = `https://picsum.photos/seed/${randomSeed}/600/600?${data.keyword}`;
  }

  // --- 6. ç¹ªåœ–é‚è¼¯ (åŒ…å«æ—¥æœŸèˆ‡å¤©æ°£) ---
  function drawCanvas(imgSource) {
    // 1. èƒŒæ™¯
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (imgSource) {
      ctx.drawImage(imgSource, 0, 0, canvas.width, canvas.height);
      // é®ç½©
      ctx.fillStyle = "rgba(0, 0, 0, 0.25)"; 
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    } else {
      // å‚™ç”¨æ¼¸å±¤èƒŒæ™¯
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, "#ff9a9e");
      gradient.addColorStop(1, "#fecfef");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // 2. ä¸­é–“ç¥ç¦èª (è‡ªå‹•æ’ç‰ˆ)
    drawMainText();

    // 3. å³ä¸‹è§’è³‡è¨Šå¡ (æ—¥æœŸ/å¤©æ°£)
    drawInfoCard();

    statusMsg.style.display = 'none';
  }

  function drawMainText() {
    const maxTextWidth = canvas.width - 80; 
    let fontSize = 80; 
    ctx.font = `900 ${fontSize}px "Microsoft JhengHei", sans-serif`;
    
    let lines = getLines(ctx, currentText, maxTextWidth);
    if (lines.length > 3) { // å­—å¤ªå¤šå°±ç¸®å°
        fontSize = 60;
        ctx.font = `900 ${fontSize}px "Microsoft JhengHei", sans-serif`;
        lines = getLines(ctx, currentText, maxTextWidth);
    }

    const lineHeight = fontSize * 1.3; 
    // å°‡æ–‡å­—ä½ç½®ç¨å¾®å¾€ä¸Šæä¸€é»ï¼Œç•™ç©ºé–“çµ¦ä¸‹æ–¹è³‡è¨Šå¡
    const totalTextHeight = lines.length * lineHeight;
    let startY = (canvas.height - totalTextHeight) / 2 - 20; 

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.strokeStyle = "black";
    ctx.lineWidth = 8;
    ctx.lineJoin = "round";
    ctx.fillStyle = "#FFFF00"; 

    for (let i = 0; i < lines.length; i++) {
        const y = startY + (i * lineHeight);
        ctx.strokeText(lines[i], canvas.width / 2, y);
        ctx.fillText(lines[i], canvas.width / 2, y);
    }
  }

  function drawInfoCard() {
    // æº–å‚™è³‡è¨Š
    const date = new Date();
    // æ ¼å¼ï¼š1æœˆ29æ—¥
    const dateStr = `${date.getMonth() + 1}æœˆ${date.getDate()}æ—¥`;
    // æ ¼å¼ï¼šé€±å››
    const dayNames = ["é€±æ—¥", "é€±ä¸€", "é€±äºŒ", "é€±ä¸‰", "é€±å››", "é€±äº”", "é€±å…­"];
    const dayStr = dayNames[date.getDay()];
    // å¤©æ°£
    const weatherIcon = getWeatherIcon(weatherInfo.code);
    const tempStr = weatherInfo.temp !== "--" ? `${weatherInfo.temp}Â°C` : "";
    const cityStr = weatherInfo.city;

    // è³‡è¨Šå¡èƒŒæ™¯ (å³ä¸‹è§’)
    const cardWidth = 240;
    const cardHeight = 80;
    const padding = 20;
    const cardX = canvas.width - cardWidth - padding;
    const cardY = canvas.height - cardHeight - padding;

    // ç•«åŠé€æ˜åœ“è§’æ¡†
    ctx.fillStyle = "rgba(255, 255, 255, 0.85)";
    roundRect(ctx, cardX, cardY, cardWidth, cardHeight, 15, true, false);

    // ç¹ªè£½æ–‡å­—
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillStyle = "#d32f2f"; // æ·±ç´…è‰²å­—é«”

    // ç¬¬ä¸€è¡Œï¼šæ—¥æœŸ + æ˜ŸæœŸ
    ctx.font = "bold 28px 'Microsoft JhengHei'";
    ctx.fillText(`${dateStr} ${dayStr}`, cardX + 15, cardY + 12);

    // ç¬¬äºŒè¡Œï¼šåœ°é» + å¤©æ°£åœ–ç¤º + æº«åº¦
    ctx.font = "bold 24px 'Microsoft JhengHei'";
    ctx.fillStyle = "#333";
    ctx.fillText(`${cityStr} ${weatherIcon} ${tempStr}`, cardX + 15, cardY + 45);
  }

  // è¼”åŠ©ï¼šç•«åœ“è§’çŸ©å½¢
  function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
    if (typeof radius === 'undefined') radius = 5;
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  function getLines(ctx, text, maxWidth) {
    let words = text.split('');
    let lines = [];
    let currentLine = words[0];
    for (let i = 1; i < words.length; i++) {
        let word = words[i];
        let width = ctx.measureText(currentLine + word).width;
        if (width < maxWidth) currentLine += word;
        else { lines.push(currentLine); currentLine = word; }
    }
    lines.push(currentLine);
    return lines;
  }

  function openSaveModal() {
    const dataURL = canvas.toDataURL("image/jpeg", 0.9);
    modalImg.src = dataURL;
    saveModal.style.display = 'flex';
  }

  // å•Ÿå‹•
  init();

</script>
</body>
</html>
